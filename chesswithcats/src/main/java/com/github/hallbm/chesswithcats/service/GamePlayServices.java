package com.github.hallbm.chesswithcats.service;

import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.stereotype.Service;

import com.github.hallbm.chesswithcats.domain.AmbiguousMoveValidator;
import com.github.hallbm.chesswithcats.domain.DefiantMoveValidator;
import com.github.hallbm.chesswithcats.domain.GameEnums.ChessMove;
import com.github.hallbm.chesswithcats.domain.GameEnums.GameOutcome;
import com.github.hallbm.chesswithcats.domain.GameEnums.GameStyle;
import com.github.hallbm.chesswithcats.domain.MoveValidator;
import com.github.hallbm.chesswithcats.domain.ObstructiveMoveValidator;
import com.github.hallbm.chesswithcats.dto.MoveDTO;
import com.github.hallbm.chesswithcats.dto.MoveResponseDTO;
import com.github.hallbm.chesswithcats.model.GamePlay;
import com.github.hallbm.chesswithcats.repository.GamePlayRepository;
import com.github.hallbm.chesswithcats.repository.GameRepository;

import jakarta.transaction.Transactional;

/**
 * Services associated with coordinating move validation rules and move persistence from the Game Controller
 */
@Service
public class GamePlayServices {

	@Autowired
	GamePlayRepository gamePlayRepo;

	@Autowired
	GameRepository gameRepo;

	/**
	 * Instantiates/initializes appropriate MoveValidator based on style of game play.
	 * Runs the moveValidator; returns populated MoveResponseDTO if move is valid (or otherwise null)
	 * that is generated by the moveValidator. This function called by Game Controller for initial
	 * move validation without persistence.
	 */
	public Optional<MoveResponseDTO> validateMove(MoveDTO moveDTO, GamePlay gamePlay) {

		MoveValidator moveValidator;
		switch(GameStyle.valueOf(moveDTO.getGameStyle().toUpperCase())) {
			case OBSTRUCTIVE: 
				moveValidator = new ObstructiveMoveValidator(gamePlay, moveDTO);
				break;
			case DEFIANT:
				moveValidator = new DefiantMoveValidator(gamePlay, moveDTO);
				break;
			case AMBIGUOUS:
				moveValidator = new AmbiguousMoveValidator(gamePlay, moveDTO);
				break;
			case CLASSIC:
			default:
				moveValidator = new MoveValidator(gamePlay, moveDTO);
		}
		return Optional.ofNullable(moveValidator.validate());
	}
	
	/**
	 * Game controller will evaluate response of the above function, and if valid, will call
	 * this function to finalize game state and persist move and effects: 
	 * Pieces moved within board of persisted gameplay object.
	 * Official chess move added to gameplay object.
	 * 50 move clock reset if pawn moved or if capture occurred.
	 * FEN updated in gameplay.
	 * Move count incremented. 
	 * GamePlay object saved.
	 */

	@Modifying
	@Transactional
	public void finalizeAndSaveGameState(MoveDTO moveDTO, MoveResponseDTO moveResponseDTO, GamePlay gamePlay) {
		
		GameBoardServices.movePiece(gamePlay.getGameBoard(), moveResponseDTO.getPieceMoves(), moveDTO.getPromotionPiece());
		
		if (gamePlay.getHalfMoves() == 1) {
			gamePlay.getGame().setOutcome(GameOutcome.INCOMPLETE);
		}
		
		boolean isCaptureMove = moveResponseDTO.getChessMoves().contains(ChessMove.CAPTURE);
		boolean isPawnMove = moveResponseDTO.getOfficialChessMove().toLowerCase().startsWith("p");
		
		if (isCaptureMove || isPawnMove) {
			gamePlay.resetFiftyMoveClock();
		} else {	
			gamePlay.incrementFiftyMoveClock();
		}
		
		gamePlay.addMove(moveResponseDTO.getOfficialChessMove()); // updates move for both String and StringBuffer
		gamePlay.incrementHalfMoves(); 
		gamePlay.updateFenSet();
	
		gamePlayRepo.save(gamePlay);
	}
	
}